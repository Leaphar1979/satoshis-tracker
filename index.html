<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Satoshis Tracker ‚Äì BTC Pair Trades</title>

  <!-- iPhone PWA settings -->
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  <meta name="apple-mobile-web-app-title" content="Satoshis Tracker" />

  <!-- App Icon -->
  <link rel="icon" type="image/png" href="icon-512.png" />
  <link rel="apple-touch-icon" href="icon-512.png" />

  <style>
    * { box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      margin: 0;
      padding: 16px;
      background: #050816;
      color: #e5e7eb;
    }

    h1 {
      margin-top: 0;
      margin-bottom: 8px;
      text-align: center;
    }

    .subtitle {
      font-size: 0.85rem;
      color: #9ca3af;
      margin-bottom: 16px;
      text-align: center;
    }

    .card {
      background: #111827;
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.5);
    }

    .card h2 {
      font-size: 1.1rem;
      margin-top: 0;
      margin-bottom: 12px;
    }

    form {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 12px;
    }

    label {
      font-size: 0.8rem;
      color: #9ca3af;
      display: block;
      margin-bottom: 4px;
    }

    input {
      width: 100%;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #374151;
      background: #020617;
      color: #e5e7eb;
      font-size: 0.9rem;
    }

    input:focus {
      outline: none;
      border-color: #22c55e;
      box-shadow: 0 0 0 1px #22c55e33;
    }

    button {
      padding: 8px 12px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-size: 0.9rem;
      white-space: nowrap;
    }

    .btn-primary {
      background: #22c55e;
      color: #022c22;
      font-weight: 600;
      width: 100%;
    }

    .btn-secondary {
      background: #1f2937;
      color: #e5e7eb;
      border: 1px solid #374151;
    }

    .btn-danger {
      background: #ef4444;
      color: #fff;
    }

    .summary {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      font-size: 0.85rem;
    }

    .summary-item {
      padding: 8px 12px;
      border-radius: 999px;
      background: #020617;
      border: 1px solid #1f2937;
    }

    .table-wrapper {
      width: 100%;
      overflow-x: auto;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.78rem;
    }

    th, td {
      padding: 6px 8px;
      border-bottom: 1px solid #1f2937;
      white-space: nowrap;
      text-align: right;
    }

    th:first-child, td:first-child { text-align: left; }

    .tag-win { color: #22c55e; font-weight: 600; }
    .tag-loss { color: #f97316; font-weight: 600; }

    .footer {
      margin-top: 16px;
      font-size: 0.75rem;
      color: #6b7280;
      text-align: center;
    }

    .row-actions button{
      font-size: 0.75rem;
      padding: 6px 10px;
      border-radius: 999px;
      width: auto;
    }

    .btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 12px;
    }

    .hint {
      font-size: 0.78rem;
      color: #94a3b8;
      margin-top: 8px;
      line-height: 1.35;
    }
  </style>
</head>
<body>

  <!-- BIG ICON -->
  <div style="text-align:center; margin-bottom:10px;">
    <img src="icon-512.png" alt="logo" style="width:120px; height:120px; border-radius:20px;">
  </div>

  <h1>Satoshis Tracker ‚Äì BTC Pair Trades</h1>
  <div class="subtitle">Record your trades and track your satoshi growth.</div>

  <!-- NEW TRADE CARD -->
  <div class="card">
    <h2>New trade</h2>

    <form id="tradeForm">
      <div>
        <label for="openDate">Open date (DD/MM/YYYY)</label>
        <input type="text" id="openDate" placeholder="03/12/2025" required>
      </div>

      <div>
        <label for="closeDate">Close date (DD/MM/YYYY)</label>
        <input type="text" id="closeDate" placeholder="05/12/2025" required>
      </div>

      <div>
        <label for="pair">Pair (auto ‚Üí XXX/BTC)</label>
        <input type="text" id="pair" placeholder="xrpbtc / xrp / XRP/BTC" required>
      </div>

      <div>
        <label for="qty">Alt quantity</label>
        <input type="number" step="0.00000001" id="qty" required>
      </div>

      <div>
        <label for="entry">Entry price (BTC)</label>
        <input type="number" step="0.00000001" id="entry" required>
      </div>

      <div>
        <label for="exit">Exit price (BTC)</label>
        <input type="number" step="0.00000001" id="exit" required>
      </div>

      <div>
        <label for="fee">Fee (BTC) [optional]</label>
        <input type="number" step="0.00000001" id="fee" placeholder="0 if paid in BNB">
      </div>

      <div>
        <button class="btn-primary">Add trade</button>
      </div>
    </form>

    <div class="hint">
      Dates accept: <b>03122025</b>, <b>3-12-25</b>, <b>03.12.2025</b>, <b>2025-12-03</b> ‚Üí saved as <b>DD/MM/YYYY</b><br/>
      Pairs accept: <b>xrpbtc</b>, <b>xrp</b>, <b>XRP/BTC</b> ‚Üí saved as <b>XRP/BTC</b>
    </div>
  </div>

  <!-- SUMMARY CARD -->
  <div class="card">
    <h2>Summary</h2>

    <div class="summary">
      <div class="summary-item" id="sumTotalTrades">Trades: 0</div>
      <div class="summary-item" id="sumWins">Win rate: 0%</div>
      <div class="summary-item" id="sumBtcResult">BTC Result: 0</div>
      <div class="summary-item" id="sumAvgRoi">Avg ROI: 0%</div>
    </div>

    <div class="btn-row">
      <button class="btn-secondary" id="btnTogglePairs">Pairs summary</button>
      <button class="btn-secondary" id="btnExport">Export JSON</button>
      <button class="btn-secondary" id="btnImport">Import JSON</button>
      <button class="btn-danger" id="btnResetAll">Reset all data</button>
      <input type="file" id="fileInput" accept="application/json" style="display:none;" />
    </div>

    <div class="hint">
      ‚úÖ Export creates a backup file of your trades.<br/>
      ‚úÖ Import can merge trades (recommended) or replace all if you choose.<br/>
      ‚ö†Ô∏è Reset deletes all saved trades on this device/browser.
    </div>
  </div>

  <!-- PAIRS SUMMARY -->
  <div class="card" id="cardPairs" style="display:none;">
    <h2>Pairs summary</h2>
    <div class="table-wrapper">
      <table id="pairsTable">
        <thead>
          <tr>
            <th>Pair</th>
            <th>Trades</th>
            <th>Wins</th>
            <th>Total BTC</th>
            <th>Avg ROI %</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <!-- TRADE HISTORY -->
  <div class="card">
    <h2>Trade history</h2>
    <div class="table-wrapper">
      <table id="tradesTable">
        <thead>
          <tr>
            <th>Open</th>
            <th>Close</th>
            <th>Pair</th>
            <th>Qty</th>
            <th>Entry (BTC)</th>
            <th>Exit (BTC)</th>
            <th>BTC In</th>
            <th>BTC Out</th>
            <th>BTC Result</th>
            <th>ROI %</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <div class="footer">
    Data stored locally (localStorage). You are farming sats. üöÄ
  </div>

  <script>
    const STORAGE_KEY = "btcPairTrades";

    // ---------- Helpers: format ----------
    function formatNumber(n, d = 8) { return Number(n).toFixed(d); }
    function formatPercent(n) { return Number(n).toFixed(2) + "%"; }

    // ---------- Normalize: DATE ----------
    // Accepts: 03122025, 3/12/2025, 03-12-25, 03.12.2025, 2025-12-03
    function normalizeDate(input) {
      const s = String(input || "").trim();
      if (!s) return null;

      // If looks like YYYY-MM-DD or YYYY/MM/DD
      const isoLike = s.match(/^(\d{4})[\/\-\.](\d{1,2})[\/\-\.](\d{1,2})$/);
      if (isoLike) {
        const y = parseInt(isoLike[1], 10);
        const m = parseInt(isoLike[2], 10);
        const d = parseInt(isoLike[3], 10);
        if (!isValidYMD(y, m, d)) return null;
        return toDDMMYYYY(d, m, y);
      }

      // Extract digits only
      const digits = s.replace(/\D/g, "");
      if (digits.length === 8) {
        // Decide between DDMMYYYY and YYYYMMDD
        const first4 = parseInt(digits.slice(0,4), 10);
        if (first4 >= 1900 && first4 <= 2099) {
          const y = first4;
          const m = parseInt(digits.slice(4,6), 10);
          const d = parseInt(digits.slice(6,8), 10);
          if (!isValidYMD(y, m, d)) return null;
          return toDDMMYYYY(d, m, y);
        } else {
          const d = parseInt(digits.slice(0,2), 10);
          const m = parseInt(digits.slice(2,4), 10);
          const y = parseInt(digits.slice(4,8), 10);
          if (!isValidYMD(y, m, d)) return null;
          return toDDMMYYYY(d, m, y);
        }
      }

      if (digits.length === 6) {
        // DDMMYY -> 20YY
        const d = parseInt(digits.slice(0,2), 10);
        const m = parseInt(digits.slice(2,4), 10);
        const y = 2000 + parseInt(digits.slice(4,6), 10);
        if (!isValidYMD(y, m, d)) return null;
        return toDDMMYYYY(d, m, y);
      }

      // If typed with separators like D/M/YYYY
      const dmY = s.match(/^(\d{1,2})[\/\-\.](\d{1,2})[\/\-\.](\d{2}|\d{4})$/);
      if (dmY) {
        const d = parseInt(dmY[1], 10);
        const m = parseInt(dmY[2], 10);
        let y = parseInt(dmY[3], 10);
        if (String(dmY[3]).length === 2) y = 2000 + y;
        if (!isValidYMD(y, m, d)) return null;
        return toDDMMYYYY(d, m, y);
      }

      return null;
    }

    function toDDMMYYYY(d, m, y) {
      const dd = String(d).padStart(2, "0");
      const mm = String(m).padStart(2, "0");
      const yyyy = String(y).padStart(4, "0");
      return `${dd}/${mm}/${yyyy}`;
    }

    function isValidYMD(y, m, d) {
      if (!Number.isFinite(y) || !Number.isFinite(m) || !Number.isFinite(d)) return false;
      if (y < 1900 || y > 2099) return false;
      if (m < 1 || m > 12) return false;
      if (d < 1 || d > 31) return false;
      const daysInMonth = new Date(y, m, 0).getDate();
      return d <= daysInMonth;
    }

    // ---------- Normalize: PAIR ----------
    function normalizePair(input) {
      let s = String(input || "").trim().toUpperCase();
      if (!s) return null;

      s = s.replace(/\s+/g, "");
      s = s.replace(/-/g, "/");

      if (s.includes("/")) {
        const [base] = s.split("/");
        if (!base) return null;
        return `${base}/BTC`;
      }

      if (s === "BTC") return null;

      if (s.endsWith("BTC") && s.length > 3) {
        const base = s.slice(0, -3);
        if (!base) return null;
        return `${base}/BTC`;
      }

      return `${s}/BTC`;
    }

    // ---------- Storage ----------
    function loadTrades() {
      try { return JSON.parse(localStorage.getItem(STORAGE_KEY) || "[]"); }
      catch { return []; }
    }

    function saveTrades(t) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(t));
    }

    // ---------- Migration ----------
    function migrateTradesIfNeeded(trades) {
      let changed = false;

      const migrated = trades.map(t => {
        const copy = { ...t };

        // old keys fallback
        const legacyDate = copy.date || copy.data;

        if (!copy.openDate || !copy.closeDate) {
          if (legacyDate) {
            copy.openDate = copy.openDate || legacyDate;
            copy.closeDate = copy.closeDate || legacyDate;
            changed = true;
          }
        }

        if (copy.pair && typeof copy.pair === "string") {
          const np = normalizePair(copy.pair);
          if (np && np !== copy.pair) {
            copy.pair = np;
            changed = true;
          }
        }

        if (copy.openDate) {
          const nd = normalizeDate(copy.openDate) || copy.openDate;
          if (nd !== copy.openDate) { copy.openDate = nd; changed = true; }
        }
        if (copy.closeDate) {
          const nd = normalizeDate(copy.closeDate) || copy.closeDate;
          if (nd !== copy.closeDate) { copy.closeDate = nd; changed = true; }
        }

        return copy;
      });

      if (changed) saveTrades(migrated);
      return migrated;
    }

    // ---------- Trade identity (avoid duplicates on import) ----------
    function tradeId(t) {
      // stable-ish id: open|close|pair|qty|entry|exit|fee
      const o = t.openDate || t.date || "";
      const c = t.closeDate || t.date || "";
      const p = (t.pair || "").toUpperCase();
      const qty = Number(t.qty || 0).toFixed(8);
      const entry = Number(t.entry || 0).toFixed(8);
      const exit = Number(t.exit || 0).toFixed(8);
      const fee = Number(t.fee || t.feeBtc || 0).toFixed(8);
      return `${o}|${c}|${p}|${qty}|${entry}|${exit}|${fee}`;
    }

    // ---------- Render ----------
    function renderTrades() {
      let trades = loadTrades();
      trades = migrateTradesIfNeeded(trades);

      let total = 0, wins = 0;
      const tbody = document.querySelector("#tradesTable tbody");
      tbody.innerHTML = "";

      trades.forEach((t, idx) => {
        total += Number(t.btcResult || 0);
        if (Number(t.btcResult || 0) > 0) wins++;

        const row = document.createElement("tr");
        row.innerHTML = `
          <td>${t.openDate || "‚Äî"}</td>
          <td>${t.closeDate || "‚Äî"}</td>
          <td>${t.pair || "‚Äî"}</td>
          <td>${formatNumber(t.qty || 0, 4)}</td>
          <td>${formatNumber(t.entry || 0)}</td>
          <td>${formatNumber(t.exit || 0)}</td>
          <td>${formatNumber(t.btcIn || 0)}</td>
          <td>${formatNumber(t.btcOut || 0)}</td>
          <td class="${Number(t.btcResult || 0) >= 0 ? "tag-win" : "tag-loss"}">${formatNumber(t.btcResult || 0)}</td>
          <td class="${Number(t.roi || 0) >= 0 ? "tag-win" : "tag-loss"}">${formatPercent(t.roi || 0)}</td>
          <td class="row-actions"><button class="btn-danger" data-idx="${idx}">Delete</button></td>
        `;
        tbody.appendChild(row);
      });

      const totalTrades = trades.length;
      const avgROI = totalTrades ? trades.reduce((s, t) => s + Number(t.roi || 0), 0) / totalTrades : 0;

      document.getElementById("sumTotalTrades").textContent = `Trades: ${totalTrades}`;
      document.getElementById("sumWins").textContent = `Win rate: ${(wins / totalTrades * 100 || 0).toFixed(2)}%`;
      document.getElementById("sumBtcResult").textContent = `BTC Result: ${formatNumber(total)}`;
      document.getElementById("sumAvgRoi").textContent = `Avg ROI: ${avgROI.toFixed(2)}%`;

      renderPairSummary(trades);
      attachDeleteHandlers();
    }

    function attachDeleteHandlers() {
      document.querySelectorAll('button[data-idx]').forEach(btn => {
        btn.addEventListener('click', () => {
          const idx = Number(btn.dataset.idx);
          const trades = migrateTradesIfNeeded(loadTrades());
          if (!Number.isFinite(idx) || idx < 0 || idx >= trades.length) return;
          if (!confirm("Delete this trade?")) return;
          trades.splice(idx, 1);
          saveTrades(trades);
          renderTrades();
        });
      });
    }

    function renderPairSummary(trades) {
      const table = document.querySelector("#pairsTable tbody");
      table.innerHTML = "";

      const groups = {};
      trades.forEach(t => {
        const p = t.pair || "‚Äî";
        if (!groups[p]) groups[p] = { trades: 0, wins: 0, btc: 0, roi: 0 };
        groups[p].trades++;
        groups[p].btc += Number(t.btcResult || 0);
        groups[p].roi += Number(t.roi || 0);
        if (Number(t.btcResult || 0) > 0) groups[p].wins++;
      });

      const keys = Object.keys(groups);
      keys.sort((a,b) => groups[b].btc - groups[a].btc);

      keys.forEach(p => {
        const g = groups[p];
        const avg = g.trades ? (g.roi / g.trades) : 0;
        const row = document.createElement("tr");
        row.innerHTML = `
          <td>${p}</td>
          <td>${g.trades}</td>
          <td>${g.wins}</td>
          <td class="${g.btc >= 0 ? "tag-win" : "tag-loss"}">${formatNumber(g.btc)}</td>
          <td class="${avg >= 0 ? "tag-win" : "tag-loss"}">${formatPercent(avg)}</td>
        `;
        table.appendChild(row);
      });

      if (!keys.length) {
        const row = document.createElement("tr");
        row.innerHTML = `<td colspan="5" style="text-align:center; color:#6b7280;">No trades</td>`;
        table.appendChild(row);
      }
    }

    // ---------- UI auto-normalize on blur ----------
    function attachAutoNormalize() {
      const openEl = document.getElementById("openDate");
      const closeEl = document.getElementById("closeDate");
      const pairEl = document.getElementById("pair");

      const fixDate = (el) => {
        const nd = normalizeDate(el.value);
        if (nd) el.value = nd;
      };

      openEl.addEventListener("blur", () => fixDate(openEl));
      closeEl.addEventListener("blur", () => fixDate(closeEl));

      pairEl.addEventListener("blur", () => {
        const np = normalizePair(pairEl.value);
        if (np) pairEl.value = np;
      });
    }

    // ---------- Form submit ----------
    document.getElementById("tradeForm").addEventListener("submit", e => {
      e.preventDefault();

      const openRaw = document.getElementById("openDate").value;
      const closeRaw = document.getElementById("closeDate").value;
      const pairRaw = document.getElementById("pair").value;

      const openDate = normalizeDate(openRaw);
      const closeDate = normalizeDate(closeRaw);
      const pair = normalizePair(pairRaw);

      if (!openDate) return alert("Invalid open date.");
      if (!closeDate) return alert("Invalid close date.");
      if (!pair) return alert("Invalid pair.");

      const qty = parseFloat(document.getElementById("qty").value);
      const entry = parseFloat(document.getElementById("entry").value);
      const exit = parseFloat(document.getElementById("exit").value);
      const fee = parseFloat(document.getElementById("fee").value || 0);

      if (!Number.isFinite(qty) || !Number.isFinite(entry) || !Number.isFinite(exit)) {
        alert("Fill quantity, entry and exit with valid numbers.");
        return;
      }

      const btcIn = qty * entry;
      const btcOut = qty * exit;
      const btcResult = btcOut - btcIn - (Number.isFinite(fee) ? fee : 0);
      const roi = btcIn ? (btcResult / btcIn) * 100 : 0;

      const trades = migrateTradesIfNeeded(loadTrades());
      trades.push({
        openDate,
        closeDate,
        pair,
        qty,
        entry,
        exit,
        fee: Number.isFinite(fee) ? fee : 0,
        btcIn,
        btcOut,
        btcResult,
        roi
      });

      saveTrades(trades);
      renderTrades();
      e.target.reset();
    });

    // ---------- Export ----------
    document.getElementById("btnExport").addEventListener("click", () => {
      const trades = migrateTradesIfNeeded(loadTrades());
      const payload = {
        app: "Satoshis Tracker",
        version: 2,
        exportedAt: new Date().toISOString(),
        count: trades.length,
        trades
      };

      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      const stamp = new Date().toISOString().slice(0,10);
      a.href = url;
      a.download = `satoshis-tracker-backup-${stamp}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();

      URL.revokeObjectURL(url);
    });

    // ---------- Import ----------
    const fileInput = document.getElementById("fileInput");
    document.getElementById("btnImport").addEventListener("click", () => fileInput.click());

    fileInput.addEventListener("change", async () => {
      const file = fileInput.files && fileInput.files[0];
      fileInput.value = "";
      if (!file) return;

      try {
        const text = await file.text();
        const data = JSON.parse(text);

        let imported = [];
        if (Array.isArray(data)) imported = data;
        else if (data && Array.isArray(data.trades)) imported = data.trades;
        else throw new Error("Invalid file format.");

        // Normalize imported
        imported = imported.map(t => {
          const openDate = normalizeDate(t.openDate || t.date || t.data);
          const closeDate = normalizeDate(t.closeDate || t.date || t.data);
          const pair = normalizePair(t.pair || t.par);
          const qty = Number(t.qty ?? t.quantidadeAlt ?? 0);
          const entry = Number(t.entry ?? t.precoEntrada ?? 0);
          const exit = Number(t.exit ?? t.precoSaida ?? 0);
          const fee = Number(t.fee ?? t.taxaBtc ?? 0);

          const btcIn = Number.isFinite(t.btcIn) ? Number(t.btcIn) : qty * entry;
          const btcOut = Number.isFinite(t.btcOut) ? Number(t.btcOut) : qty * exit;
          const btcResult = Number.isFinite(t.btcResult) ? Number(t.btcResult) : (btcOut - btcIn - fee);
          const roi = Number.isFinite(t.roi) ? Number(t.roi) : (btcIn ? (btcResult / btcIn) * 100 : 0);

          return { openDate, closeDate, pair, qty, entry, exit, fee, btcIn, btcOut, btcResult, roi };
        }).filter(t => t.openDate && t.closeDate && t.pair && Number.isFinite(t.qty) && Number.isFinite(t.entry) && Number.isFinite(t.exit));

        const mode = prompt(
          "Import mode:\n\nType 1 to MERGE (recommended)\nType 2 to REPLACE ALL\n\nYour choice:",
          "1"
        );

        if (mode !== "1" && mode !== "2") {
          alert("Import cancelled.");
          return;
        }

        if (mode === "2") {
          if (!confirm("Replace ALL local trades with imported file?")) return;
          saveTrades(imported);
          renderTrades();
          alert(`Imported ${imported.length} trades (replaced).`);
          return;
        }

        // MERGE
        const existing = migrateTradesIfNeeded(loadTrades());
        const existingIds = new Set(existing.map(tradeId));

        let added = 0;
        imported.forEach(t => {
          const id = tradeId(t);
          if (!existingIds.has(id)) {
            existing.push(t);
            existingIds.add(id);
            added++;
          }
        });

        saveTrades(existing);
        renderTrades();
        alert(`Imported ${imported.length} trades.\nAdded: ${added}\nSkipped duplicates: ${imported.length - added}`);
      } catch (err) {
        console.error(err);
        alert("Could not import file. Make sure it's a valid JSON backup.");
      }
    });

    // ---------- Reset all ----------
    document.getElementById("btnResetAll").addEventListener("click", () => {
      const ok = confirm("This will DELETE ALL saved trades on this device/browser.\n\nContinue?");
      if (!ok) return;
      localStorage.removeItem(STORAGE_KEY);
      renderTrades();
      alert("All data reset.");
    });

    // ---------- Toggle pairs ----------
    document.getElementById("btnTogglePairs").addEventListener("click", () => {
      const c = document.getElementById("cardPairs");
      c.style.display = c.style.display === "none" ? "block" : "none";
    });

    // init
    attachAutoNormalize();
    renderTrades();
  </script>
</body>
</html>
